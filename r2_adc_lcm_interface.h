// serial_lcm_interface.h
// Class and generic methods for an LCM interface to an A2D device
//

#ifndef R2_ALI_H
#define R2_ALI_H

#include <stdio.h> // for fprintf, stderr
#include <stdint.h> // for int64_t
#include <termios.h> // for serial port
#include <time.h> // for nanosleep
#include <unistd.h> // for getpid

#include <lcm/lcm.h>

// Requires source generated by lcm-gen -c for raw and management lcmtypes
//     raw:        git@bitbucket.org:mbari/raw-lcmtypes.git
//     management: git@bitbucket.org:mbari/process-management-lcmtypes.git
#include "raw_adc_t.h"
#include "management_control_t.h"
#include "management_process_t.h"
#include "management_syslog_t.h"

#include "r2_epoch.h"
#include "r2_analog_digital_converter.h"

struct r2_ali {
    management_process_t process;
    struct r2_adc * adc;
    lcm_t * lcm;
    management_control_t_subscription_t * management_control_subscription;
};

typedef void ( * r2_ali_publisher )( struct r2_ali * self, const long count,
        const int64_t epoch_usec );

struct r2_ali * r2_ali_create(const char * name, const char * device,
        const int bits, const double vref, const double scale,
        const double offset, const char * provider);

static void r2_ali_destroy( struct r2_ali * self );

static void r2_ali_management_control_handler( const lcm_recv_buf_t *rbuf,
        const char * channel, const management_control_t * msg,
        void * user);

static void r2_ali_raw_adc_publisher( lcm_t * lcm, const char * channel,
        raw_adc_t * msg, const long count, const int64_t epoch_usec );

static void r2_ali_stream( struct r2_ali * self, r2_ali_publisher publisher,
        const int64_t period );

#endif // R2_ALI_H

#ifndef R2_ALI_I
#define R2_ALI_I

struct r2_ali * r2_ali_create(const char * name, const char * device,
        const int bits, const double vref, const double scale,
        const double offset, const char * provider)
{
    struct r2_ali * self = calloc(1, sizeof(struct r2_ali));

    self->process.name = (char *)name;
    self->process.id = getpid();

    if( !self ) {
        fprintf(stderr, "Could not allocate memory for ADC-LCM interface.");
        return NULL;
    }

    self->adc = r2_adc_create( device, bits, vref, scale, offset );
    if( !self->adc ) {
        fprintf(stderr, "Could not create ADC interface.");
        return NULL;
    }

    self->lcm = lcm_create( provider );
    if( !self->lcm ) {
        fprintf(stderr, "Could not create LCM instance.");
        return NULL;
    }

    char control_channel[strlen( name ) + 5];
    sprintf( control_channel, "%s.ctrl", name );

    self->management_control_subscription = management_control_t_subscribe(
            self->lcm, control_channel, &r2_ali_management_control_handler,
            NULL);

    return self;
}

void r2_ali_destroy( struct r2_ali * self)
{
    r2_adc_destroy(self->adc);

    // unsubscribe from the standard subscriptions
    management_control_t_unsubscribe(self->lcm,
            self->management_control_subscription);

    lcm_destroy(self->lcm);
}

/*** Input handlers ***/

void r2_ali_management_control_handler(const lcm_recv_buf_t *rbuf,
        const char * channel, const management_control_t * msg,
        void * user)
{
    printf("Received message on channel %s: signal=%s\n", channel, msg->signal);
    // TODO: Let incoming signals actually do something!
}


/*** Output publishers ***/

void r2_ali_raw_adc_publisher( lcm_t * lcm, const char * channel,
        raw_adc_t * msg, const long counts, const int64_t epoch_usec )
{
    msg->epoch_usec = epoch_usec;
    msg->counts = counts;
    msg->volts = 0; // TODO: msg->volts = r2_adc_volts( self->adc, counts );
    raw_adc_t_publish( lcm, channel, msg );
}

/*** Streaming methods ***/

void r2_ali_stream( struct r2_ali * self, r2_ali_publisher publisher,
        const int64_t period_usec )
{
    const struct timespec period = { 0, 950 * period_usec };
    fd_set rfds; // file descriptors to check for readability with select
    const int afd = self->adc->fd;
    const int lfd = lcm_get_fileno(self->lcm);
    const int maxfd = afd > lfd ? afd + 1 : lfd + 1;
    int64_t epoch_usec = 0;
    int run = 1;

    while( run ) {
        // add both i/o file descriptors to the fdset for select
        FD_ZERO(&rfds);
        FD_SET(afd, &rfds);
        FD_SET(lfd, &rfds);

        if( -1 != select( maxfd, &rfds, NULL, NULL, NULL ) ) {
            if( FD_ISSET( afd, &rfds ) ) { // check for ADC input first
                long count = r2_adc_read( self->adc ); // get the counts
                epoch_usec = r2_epoch_usec_now(); // update timestamp
                publisher( self, count, epoch_usec ); // process & publish
            }
            if( FD_ISSET( lfd, &rfds ) ) { // then check for LCM input
                lcm_handle( self->lcm ); // handle all LCM input with handlers
            }
            if( r2_epoch_usec_now() - epoch_usec < period_usec ) {
                nanosleep( &period, NULL ); // sleep if you recently read a sample
            }
        } else {
            perror( "r2_ali_stream select()" );
            if( errno == EINTR ) {
                run = 1; // Keep going if interrupted by a system call.
                // TODO: Check and handle signals instead.
                //       SIGTERM could be used to terminate cleanly.
            } else {
                run = 0;
            }
        }
    }
}

/*** Polling methods ***/

#endif // R2_ALI_I
